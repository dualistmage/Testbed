[124] To see the advantage of our method over the naive algorithm which prunes the full-text suffix array to obtain the word suffix array, Table 4 shows the construction times and peak space consumption of two state-of-the-art algorithms for constructing (full-text) suffix arrays, MSufSort-3.0 [28] and deep-shallow [29].
[81] The full-text suffix array would have the same time- and space-bounds, with k substituted by n >> k, and occ by occ >> occ, where occ is the number of not necessarily word-aligned occurrences of the pattern. method space usage (words) time bounds bin-naive k O(m log k + occ) bin-improved (1 + C)k, C  1 O((m - log(Ck)) log k + occ) bin-lcp 2k O(m + log k + occ) esa-search 2k + O(k/ log k) O(m|| + occ)
[85] This result is interesting because it says that, in the case of a tokenized text with long words on average (e.g. dictionary of URLs), the word-based suffix array takes the same space as the best compressed indexes (cf. [8]), but it would need less space to be constructed.
[28] The first result addressing this issue in the word-based indexing realm is due to Anderson et al. [1] who showed that the word suffix tree can be constructed in O(n) expected time and O(k) working space.
[39] We define a new data structure called the word(-based) suffix array and show how it can be constructed directly in optimal time and space; i.e., without first constructing the sparse suffix tree.
[1] Surprisingly enough, it is not yet known how to build directly a suffix array that indexes just the k positions at word-boundaries of a text T [1, n], taking O(n) time and O(k) space in addition to T .
[50] As query time is faster by up to a factor 3 without post-filtering the word-aligned occurrences, and up to 5 orders of magnitude including post-filtering, we exclude the idea of using a full-text suffix array for finding word-aligned occurrences already at this point.
[87] As searching the word suffix array can be done with the same methods as in the full-text suffix array we keep the discussion short (see also Table 1); the purpose of this section is the completeness of exposition, and to prepare for the experiments in the following section.
[101] We will now show that this LCP-table can be computed in O(n) time in the order of inverse word suffix array A-1 which is defined as A[A-1 [i]] = I[i]; i.e., A-1 [i] tells us where the i'th-longest suffix among all indexed suffixes from T can be found in A.
[5] To support this, we have run a large set of experiments showing that word-based suffix arrays may be constructed twice as fast as their full-text counterparts, and with a working space as low as 20%.
